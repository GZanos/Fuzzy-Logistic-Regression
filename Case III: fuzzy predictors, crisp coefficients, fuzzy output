
#''''''''''Comment: Adjust lines 4-12 to import a different dataset'''''''''''''''''#

## Import dataset ##
#-------------------------------------------------------------------------------#
Immunotherapy <- read.csv("Immunotherapy.csv", header = TRUE)
nrow(Immunotherapy) #sample size is 90
ncol(Immunotherapy) #there are 7 variables and 1 response variable called 'Result_of_Treatment'
table(Immunotherapy$Result_of_Treatment) #imbalanced towards 1s (79%)
colnames(Immunotherapy)[1] <- "sex"
str(Immunotherapy)
#-------------------------------------------------------------------------------#


#''''''''''Comment: Adjust lines 20-37 to set tunning settings'''''''''''''''''#

## Set Model Implementation Settings##
#-------------------------------------------------------------------------------#

b0_lwr <- c(-1)
b0_upper <- c(1)
bi_lower <- c(-1)
bi_upper <- c(1)
Iterations <- c(10000)
Fuzzification_factor <- c(1)
left_point_symmetry <- c(1)
right_point_symmetry <- c(1)
fuz_Y0_min <- c(0)
fuz_Y0_max <- c(1.5)
fuz_Y1_min <- c(0)
fuz_Y1_max <- c(1.5)
TFNthreshold_1 <- c(0.4)
TFNthreshold_2 <- c(0.5)
TFNthreshold_3 <- c(0.6)
ARRAYthreshold_1 <- c(0.4)
ARRAYthreshold_2 <- c(0.5)
ARRAYthreshold_3 <- c(0.6)
N <- nrow(Immunotherapy)

# (i) Join Actual bs with Model bs info
dfi_i_comb <- data.frame(b0_lwr, b0_upper, bi_lower, bi_upper)

# (ii) = join iterations with fuzzification and asymmetry info
df_iter <- data.frame(Iterations)
df_fuzzy <- data.frame(Fuzzification_factor)
df_assymetry <- data.frame(left_point_symmetry,right_point_symmetry)
df_iter_repeated <- data.frame(df_iter[rep(seq_len(nrow(df_iter)), each=nrow(df_fuzzy)),])
df_iter_fuzzy <- cbind(df_iter_repeated, df_fuzzy)
df_iter_fuzzy_repeated <- data.frame(df_iter_fuzzy[rep(seq_len(nrow(df_iter_fuzzy)), each=nrow(df_assymetry)),])
df_iter_fuzzy_assymetry <- cbind(df_iter_fuzzy_repeated, df_assymetry)

# (iii) = join threshold with N and fuzzification of Y limits info
df_thres <- data.frame(TFNthreshold_1, TFNthreshold_2, TFNthreshold_3, ARRAYthreshold_1, ARRAYthreshold_2, ARRAYthreshold_3)
df_N <- data.frame(N)
df_N_repeated <- data.frame(df_N[rep(seq_len(nrow(df_N)), each=nrow(df_thres)),])
df_N_thres <- cbind(df_N_repeated, df_thres)
df_fuz_lmt <- data.frame(fuz_Y0_min, fuz_Y0_max, fuz_Y1_min, fuz_Y1_max)
df_N_thres_repeated <- data.frame(df_N_thres[rep(seq_len(nrow(df_N_thres)), each=nrow(df_fuz_lmt)),])
df_N_thres_fuzlmt <- cbind(df_N_thres_repeated, df_fuz_lmt)

# (iv) final joins
df_iii_repeated <- data.frame(df_N_thres_fuzlmt[rep(seq_len(nrow(df_N_thres_fuzlmt)), each=nrow(dfi_i_comb)),])
df_i_iii_join <- cbind(df_iii_repeated, dfi_i_comb)
df_ii_repeated <- data.frame(df_iter_fuzzy_assymetry[rep(seq_len(nrow(df_iter_fuzzy_assymetry)), each=nrow(df_i_iii_join)),])
df_final <- cbind(df_ii_repeated,df_i_iii_join)

# Final Data prep and export
nrow(df_final) #gives final number of scenarios

colnames(df_final)[1] <- "Iterations"
colnames(df_final)[2] <- "Fuzzification_Factor"
colnames(df_final)[3] <- "Left_Point_Symmetry"
colnames(df_final)[4] <- "Right_Point_Symmetry"
colnames(df_final)[5] <- "N_size_for_Xi"
colnames(df_final)[6] <- "TFN_Threshold_a"
colnames(df_final)[7] <- "TFN_Threshold_b"
colnames(df_final)[8] <- "TFN_Threshold_c"
colnames(df_final)[9] <- "ARRAYthreshold_a"
colnames(df_final)[10] <- "ARRAYthreshold_b"
colnames(df_final)[11] <- "ARRAYthreshold_c"
colnames(df_final)[12] <- "Fuzzy_Y0_min_limit"
colnames(df_final)[13] <- "Fuzzy_Y0_max_limit"
colnames(df_final)[14] <- "Fuzzy_Y1_min_limit"
colnames(df_final)[15] <- "Fuzzy_Y1_max_limit"

write.csv(df_final, "Model_Parameter_Settings.csv")  #''''''''''Comment: This CSV will export to your directory with given settings''''''''#



## Fuzzy Logistic Regression Model ##
#-------------------------------------------------------------------------------#

library(FuzzyR)
library(openxlsx)
library(FuzzyNumbers)
library(Rfast)

#############################################
#### Required Functions & Error Measures ####
#############################################

# Addition Function
add_TFN <- function(TFN1, TFN2) {
  TFN3 <- c((TFN1[1]+TFN2[1]) , (TFN1[2]+TFN2[2]) , (TFN1[3]+TFN2[3]))
  TFN3
}


# Subtraction Function
sub_TFN <- function(TFN1, TFN2) {
  TFN3 <- c((TFN1[1]-TFN2[3]) , (TFN1[2]-TFN2[2]) , (TFN1[3]-TFN2[1]))
  TFN3
}


# Multiplication Function
mult_TFN <- function(TFN1, TFN2) {
  TFN3 <- array(NA,3)
  TFN3[1] <- min(TFN1[1]*TFN2[1] , TFN1[1]*TFN2[3] , TFN1[3]*TFN2[1] , TFN1[3]*TFN2[3])
  TFN3[2] <- TFN1[2]*TFN2[2]
  TFN3[3] <- max(TFN1[1]*TFN2[1] , TFN1[1]*TFN2[3] , TFN1[3]*TFN2[1] , TFN1[3]*TFN2[3])
  TFN3
}


# Division Function
div_TFN <- function(TFN1, TFN2) {
  TFN3 <- array(NA,3)
  TFN3[1] <- min(TFN1[1]/TFN2[1] , TFN1[1]/TFN2[3] , TFN1[3]/TFN2[1] , TFN1[3]/TFN2[3])
  TFN3[2] <- TFN1[2]/TFN2[2]
  TFN3[3] <- max(TFN1[1]/TFN2[1] , TFN1[1]/TFN2[3] , TFN1[3]/TFN2[1] , TFN1[3]/TFN2[3])
  TFN3
}


# Membership Function using FuzzyR
fn_member_grades <- function(TFN, MTX, x){
  w <- MTX[TFN,]
  mf <- genmf('trimf', w)
  print("The a-cut evaluation of x elemnents is:")
  e <- evalmf(x, mf)
  e <- cbind(e, x)
  return(list(TFN_Selected = w, MF_Evaluation = e))
}


# Alpha-cut interval using FuzzyR
a_cut_mf <- function(TFN, alpha, x) {
  w <- TFN
  mf <- genmf('trimf', w)
  e <- evalmf(x, mf)
  edf <- data.frame(e, x)
  edf <- subset(edf, e>=a)
  edf
}


# Definition 2.4 - method a
abs_tfn_1 <- function(TFN){
  abs_w <- array(NA,3)
  w <- TFN
  abs_w[1] <- max(min(w) , -max(w) , 0)
  abs_w[2] <- if (w[2]>=0) {
    w[2]
  } else if (w[2]<0) {
    abs(w[2])
  } 
  abs_w[3] <- max(-min(w) , max(w)) 
  abs_w
}


# Definition 2.4 - method b
abs_tfn_2 <- function(TFN){
  abs_w <- array(NA,3)
  w <- TFN
  abs_w[1] <- max(min(w) , -max(w) , 0) 
  abs_w[3] <- max(-min(w) , max(w))
  distw <- (w[2]-w[1])/(w[3]-w[1])
  distabsw <- abs_w[3]-abs_w[1]
  abs_w[2] <- abs_w[1]+(distw*distabsw)
  abs_w
}


# Definition 2.5
random_crisps <- function(n, min, max) {
  round(runif(n = n, min=min, max=max), 3)
}


# Definition 2.6
random_TFNs <- function(min, max, n=3) {
  round(sort(runif(n = n, min=min, max=max)),3)
}

Random_TFNs_norm <- function(mean, sd, n=3) {
  round(sort(rnorm(n = n, mean=mean, sd=sd)),3)
}


# Calculate MSE
MSE_calc <- function(actual,predicted) {
  if (nrow(actual) != nrow(predicted)){
    stop("Unequal number of numbers in actual and predicted!")
  }
  n <- nrow(actual)
  total <- 0
  for(i in 1:n){
    total <- total + sum((actual[i,]-predicted[i,])^2)
  }
  MSE_fuzzy = total / n
  return(MSE_fuzzy = MSE_fuzzy)
}


# Root Mean Squared Error
RMSE <- function(actual, predicted) {
  n_rows <- nrow(predicted)
  rmse <- numeric(n_rows)
  for (i in 1:n_rows) {
    rmse[i] <- sqrt(mean((predicted[i,] - actual[i,])^2))
  }
  avg_rmse <- mean(rmse)
  return(avg_rmse)
}


# MAE
MAE_calc <- function(actual,predicted) {
  if (nrow(actual) != nrow(predicted)){
    stop("Unequal number of numbers in actual and predicted!")
  }
  n <- nrow(actual)
  total <- 0
  for(i in 1:n){
    total <- total + sum(abs(actual[i,]-predicted[i,]))
    MAE_fuzzy <- total / n
  }
  return(MAE_fuzzy = MAE_fuzzy)
}


# Specificity
specificity <- function(actuals, predictions) {
  # Define the threshold for classification
  threshold <- 0.5
  # Convert the matrices to vectors
  actuals_vec <- as.vector(actuals)
  predictions_vec <- as.vector(predictions)
  # Determine the true negatives and false positives
  tn <- sum(actuals_vec < threshold & predictions_vec < threshold)
  fp <- sum(actuals_vec < threshold & predictions_vec >= threshold)
  # Calculate specificity
  specificity <- tn / (tn + fp)
  return(specificity)
}


# Sensitivity
sensitivity <- function(actuals, predictions) {
  # Define the threshold for classification
  threshold <- 0.5
  # Convert the matrices to vectors
  actuals_vec <- as.vector(actuals)
  predictions_vec <- as.vector(predictions)
  # Determine the true positives and false negatives
  tp <- sum(actuals_vec >= threshold & predictions_vec >= threshold)
  fn <- sum(actuals_vec >= threshold & predictions_vec < threshold)
  # Calculate sensitivity
  sensitivity <- tp / (tp + fn)
  return(sensitivity)
}


# F1 Score
f1_score <- function(actuals, predictions) {
  # Define the threshold for classification
  threshold <- 0.5
  # Convert the matrices to vectors
  actuals_vec <- as.vector(actuals)
  predictions_vec <- as.vector(predictions)
  # Determine the true positives, false positives, and false negatives
  tp <- sum(actuals_vec >= threshold & predictions_vec >= threshold)
  fp <- sum(actuals_vec < threshold & predictions_vec >= threshold)
  fn <- sum(actuals_vec >= threshold & predictions_vec < threshold)
  # Calculate precision and recall
  precision <- tp / (tp + fp)
  recall <- tp / (tp + fn)
  # Calculate F1 score
  f1_score <- 2 * precision * recall / (precision + recall)
  return(f1_score)
}


# MCC (Matthews Correlation Coefficient)
MCC <- function(actual, predicted) {
  # Calculate the MCC for each row of the matrices
  m <- nrow(actual)
  mcc_vals <- numeric(m)
  for (i in 1:m) {
    a <- actual[i, ]
    p <- predicted[i, ]
    # Calculate the confusion matrix
    tp <- sum(p >= a & p <= a[3])
    tn <- sum(p <= a & p >= a[1])
    fp <- sum(p > a[3])
    fn <- sum(p < a[1])
    # Calculate MCC
    num <- tp * tn - fp * fn
    denom <- sqrt((tp + fp) * (tp + fn) * (tn + fp) * (tn + fn))
    if (denom == 0) {
      mcc_vals[i] <- 0
    } else {
      mcc_vals[i] <- num / denom
    }
  }
  # Return the average MCC across all rows
  mean(mcc_vals)
}



# Function to find p values from predictors
find_p_cs3_4 <- function(X1, X2, X3, b0, b1, b2, b3) {
  b1x1 <- X1*b1
  b2x2 <- X2*b2
  b3x3 <- X3*b3
  sum1 <- b1x1 + b2x2 + b3x3
  sum2 <- b0 + sum1 
  p <- exp(sum2) / (1 + exp(sum2)) 
  return(round(rowMeans(p), digits = 4))
}


# Function to estimate Y
Estimate_Y_cs3_logit <- function(X, b.lwr, b.upr, b0.lwr, b0.upr){
  Np <- length(b.lwr)
  b0 <- random_crisps(1, b0.lwr, b0.upr) 
  b <- vector()
  for (i in 1:Np) {
    b[i] <- random_crisps(1, bi_lower[i], bi_upper[i]) 
  }
  n <- nrow(X[[1]]) 
  bx <- 0
  for(j in 1:Np) {
    bx <- bx + b[j]*Xlist[[j]] 
  }
  predy <- matrix(nrow = n, ncol = ncol(bx))
  for (i in 1:n) {
    predy[i,] <- 1 / (1 + exp(-bx[i,]))
    predy[i,] <- sort(predy[i,])
  }
  return(list("predictions" = predy, "b0" = b0, "bi" = b))
}


# Function to run estimate_Y many times
Optimize_Y_gen <- function(m, X, b.lwr, b.upr, b0.lwr, b0.upr){
  results <- list()
  for (i in 1:m) {
    results[[i]] <- Estimate_Y_cs3_logit(X, b.lwr, b.upr, b0.lwr, b0.upr)
  }
  # store all predictions
  store_predY <- list()
  for (i in 1:m) {
    store_predY[[i]] <- results[[i]]$predictions
  }
  # store all beta 0
  store_b0 <- matrix(NA, nrow = m, ncol = 3)
  for (i in 1:m) {
    store_b0[i,] <- results[[i]]$b0
  }
  # store all beta i
  store_bi <- list()
  for (i in 1:m) {
    store_bi[[i]] <- results[[i]]$bi
  }
  output_list <- list(store_predY, store_b0, store_bi)
}


# Function to find error
Error_cs_gen <- function(Experiment, Y, saveResults = TRUE){
  store_predY <- Experiment
  t <- length(store_predY)
  MSE_list <- list() 
  MAE_list <- list()
  RMSE_list <- list()
  for (i in 1:t) {
    MSE_list[[i]] <- MSE_calc(Y,store_predY[[i]])
    MAE_list[[i]] <- MAE_calc(Y,store_predY[[i]])
    RMSE_list[[i]] <- RMSE(Y,store_predY[[i]])
  }
  mtx_seq <- seq(1:Iterations) 
  error_results <- do.call(rbind, Map(data.frame, Matrix=mtx_seq, MSE=MSE_list, MAE=MAE_list ,RMSE=RMSE_list))
  if (saveResults){
    write.csv(error_results, "error_results.csv")
  }
  return(error_results)
}

# Function to fuzzify Y values
fuzzify_Y <- function(Y, m, l=1, r=1){ 
  center_point <- ifelse(Y == 0, 0, 1) 
  set.seed(123) 
  left_point <- array(NA, length(center_point))
  right_point <- array(NA, length(center_point))
  left_point[which(center_point == 0)] <- 0 - l * m * runif(length(which(center_point == 0)), min = fuzzy_y0_min, max = fuzzy_y0_max) 
  right_point[which(center_point == 0)]  <- 0 + r * m * runif(length(which(center_point == 0)), min = fuzzy_y0_min, max = fuzzy_y0_max)
  
  left_point[which(center_point == 1)] <- 1 - l * m * runif(length(which(center_point == 1)), min = fuzzy_y1_min, max = fuzzy_y1_max) 
  right_point[which(center_point == 1)]  <- 1 + r * m * runif(length(which(center_point == 1)), min = fuzzy_y1_min, max = fuzzy_y1_max)
  
  
  TFN_Y_df <- data.frame(left_point, center_point, right_point) 
  TFN_Y <- as.matrix(TFN_Y_df) 
  return(TFN_Y)
}

fuzzify_triangular <- function(X, w) {
  U <- range(X) # Define the universe of discourse
  fuzzy_X <- matrix(NA, nrow = length(X), ncol = 3)
  for (j in seq_along(X)) { # Fuzzify the vector
    fuzzy_X[j,] <- c(X[j] - w, X[j], X[j] + w)
  }
  return(fuzzy_X)
}

fuzzify_bin <- function(Y, m, l=1, r=1){ 
  center_point <- ifelse(Y == 0, 0, 1) 
  set.seed(123) 
  left_point <- array(NA, length(center_point))
  right_point <- array(NA, length(center_point))
  left_point[which(center_point == 0)] <- 0 - l * m * runif(length(which(center_point == 0)), min = 0, max = 0.5) 
  right_point[which(center_point == 0)]  <- 0 + r * m * runif(length(which(center_point == 0)), min = 0, max = 1.5)
  
  left_point[which(center_point == 1)] <- 1 - l * m * runif(length(which(center_point == 1)), min = 0, max = 1.5) 
  right_point[which(center_point == 1)]  <- 1 + r * m * runif(length(which(center_point == 1)), min = 0, max = 0.5)
  
  
  TFN_Y_df <- data.frame(left_point, center_point, right_point) 
  TFN_Y <- as.matrix(TFN_Y_df) 
  return(TFN_Y)
}
#-------------------------------------------------------------------------------------------------------------------#



#''''''''''Comment: Adjust lines 455-461 to fuzzify the predictors by changing "w". '''''''''''''''''#
#''''''''''Comment: "w" here represents the degree of fuzzification and is defined by the user'''''''#

## Fuzzify the data
#------------------------------------------------------------------------------------

f.sex <- fuzzify_bin(Immunotherapy$sex, m=1)
f.age <- fuzzify_triangular(Immunotherapy$age,w=0.1*mean(Immunotherapy$age))
f.Time <- fuzzify_triangular(Immunotherapy$Time,w=0.15*mean(Immunotherapy$Time))
f.Number_of_Warts <- fuzzify_triangular(Immunotherapy$Number_of_Warts,w=0.06*mean(Immunotherapy$Number_of_Warts))
f.Type <- fuzzify_triangular(Immunotherapy$Type,w=0.23*mean(Immunotherapy$Type))
f.Area <- fuzzify_triangular(Immunotherapy$Area,w=0.4*mean(Immunotherapy$Area))
f.induration_diameter <- fuzzify_triangular(Immunotherapy$induration_diameter,w=0.04*mean(Immunotherapy$induration_diameter))
#------------------------------------------------------------------------------------



## --- MODEL START --- ##
#-----------------------#
# startTime = proc.time()

###############################
#### Simulation Parameters ####
###############################

# Import simulation settings file
model_settings <- read.csv("Model_Parameter_Settings.csv")  #''''''''''Comment: settings file imported here'''''''''''''''''#
str(model_settings) #str to check

for ( simControl in 1:nrow(model_settings)){
  
  # Input parameters
  iterations <- model_settings$Iterations[simControl]
  fuzzy_factor <- model_settings$Fuzzification_Factor[simControl]
  left_symmetry <- model_settings$Left_Point_Symmetry[simControl]
  right_symmetry <- model_settings$Right_Point_Symmetry[simControl]
  N_of_X <- model_settings$N_size_for_Xi[simControl]
  TFN_threshold_a <- model_settings$TFN_Threshold_a[simControl]
  TFN_threshold_b <- model_settings$TFN_Threshold_b[simControl]
  TFN_threshold_c <- model_settings$TFN_Threshold_c[simControl]
  fuzzy_y0_min <- model_settings$Fuzzy_Y0_min_limit[simControl]
  fuzzy_y0_max <- model_settings$Fuzzy_Y0_max_limit[simControl]
  fuzzy_y1_min <- model_settings$Fuzzy_Y1_min_limit[simControl]
  fuzzy_y1_max <- model_settings$Fuzzy_Y1_max_limit[simControl]
  pred_b0_lwr <- model_settings$b0_lwr[simControl]
  pred_b0_upr <- model_settings$b0_upper[simControl]
  pred_b1_lwr <- model_settings$bi_lower[simControl]
  pred_b1_upr <- model_settings$bi_upper[simControl]
  pred_b2_lwr <- model_settings$bi_lower[simControl]
  pred_b2_upr <- model_settings$bi_upper[simControl]
  pred_b3_lwr <- model_settings$bi_lower[simControl]
  pred_b3_upr <- model_settings$bi_upper[simControl]
  pred_b4_lwr <- model_settings$bi_lower[simControl]
  pred_b4_upr <- model_settings$bi_upper[simControl]
  pred_b5_lwr <- model_settings$bi_lower[simControl]
  pred_b5_upr <- model_settings$bi_upper[simControl]
  pred_b6_lwr <- model_settings$bi_lower[simControl]
  pred_b6_upr <- model_settings$bi_upper[simControl]
  pred_b7_lwr <- model_settings$bi_lower[simControl]
  pred_b7_upr <- model_settings$bi_upper[simControl]
  #''''''''''Comment: add more pred_bi_lwr and pred_bi_upr as required, based on number of predictors'''''''#
  
  
  ## Model settings ##
  #------------------#
  
  #''''''''''Comment: Adjust lines 517-518 based on number of predictors'''''''''''''''''#
  bi_lower <- c(pred_b1_lwr, pred_b2_lwr, pred_b3_lwr, pred_b4_lwr, pred_b5_lwr, pred_b6_lwr, pred_b7_upr)
  bi_upper <- c(pred_b1_upr, pred_b2_upr, pred_b3_upr, pred_b4_upr, pred_b5_upr, pred_b6_upr, pred_b7_upr)
  
  b0_lwr <- pred_b0_lwr
  b0_upper <- pred_b0_upr
  
  #''''''''''Comment: Change Xlist based on predictors in your data'''''''''''''''''#
  Xlist <- list(f.sex, f.age, f.Time, f.Number_of_Warts, f.Type, f.Area, f.induration_diameter)
  
  Iterations <- iterations
  Fuzzification_factor <- fuzzy_factor
  left_point_symmetry <- left_symmetry
  right_point_symmetry <- right_symmetry
  Y <- Immunotherapy$Result_of_Treatment
  #------------------#

  
  ## Model Run below ##

  # Fuzzify the Ys
  TFN_Y <- fuzzify_Y(Y, Fuzzification_factor, l=left_point_symmetry, r=right_point_symmetry)
  
  # MC-I 
  MCI <- Optimize_Y_gen(Iterations, Xlist, bi_lower, bi_upper, b0_lwr, b0_upper)
  Predictions_MCI <- MCI[[1]] 
  
  # Compare each vertex position for each predicted p against 0.5 and replace with 0s or 1s.
  TFNthreshold <- TriangularFuzzyNumber(TFN_threshold_a, TFN_threshold_b, TFN_threshold_c) 
  ARRAYthreshold <- c(TFN_threshold_a, TFN_threshold_b, TFN_threshold_c)
  
  for (i in 1:length(Predictions_MCI)) {
    mat <- Predictions_MCI[[i]]
    for (j in 1:nrow(mat)){
      TFNprob <- TriangularFuzzyNumber(mat[j,1], mat[j,2], mat[j,3])
      diffTFN <- sub_TFN(mat[j,], ARRAYthreshold )
      diffTFN <-  TriangularFuzzyNumber(diffTFN[1],diffTFN[2],diffTFN[3])
      
      # Use the expected value of TFN predicted probability to decide on the vertex being 0 or 1
      if (expectedValue(TFNprob) < 0.5){ # Dubois D., Prade H. (1987), The mean value of a fuzzy number, Fuzzy Sets and Systems 24, pp. 279-300.
        b_thresholded <- 0
      } else {
        b_thresholded <- 1
      }
      # Use the width of the difference between the TFN threshold and TFN predicted probability to add uncertainty around 0 or 1.
      a_new <- b_thresholded - width(diffTFN)
      c_new <- b_thresholded + width(diffTFN)
      
      # shiftedTFN <- TriangularFuzzyNumber(a_new, b_thresholded, c_new)
      
      mat[j, 2] <- b_thresholded
      mat[j, 1] <- a_new
      mat[j, 3] <- c_new
    }
    Predictions_MCI[[i]] <- mat
  }
  
  # Filter good predictions
  #Predictions_MCI_good <- filter_matrices(Predictions_MCI)
  
  # Error Optimization
  errors <- Error_cs_gen(Predictions_MCI, TFN_Y)
  
  bestRun <- as.array(colMins(as.matrix(errors[,-c(1)])))
  names(bestRun) <- colnames(errors[,-c(1)])
  errorEst <- round(apply(errors, 2, min), 3)
  errorEst <- errorEst[2:4]
  # 
  # stopTime = proc.time()
  # duration = as.numeric(stopTime - startTime)
  #   duration = round((duration/60),2)
  #   duration_mins <- c(duration[3],duration[3],duration[3])
  
  # Check for number of good predictions 
  numLess <- array()
  for (ii in 1:Iterations){
    numLess[ii] <- length(which(Predictions_MCI[[ii]][,2]<0.5))
  }
  Percentage_good <- sum(numLess > 20 & numLess < 80)/Iterations
  Percentage_good <- c(Percentage_good,Percentage_good,Percentage_good)
  
  # Initialize empty vectors to store the performance metrics for each run
  nBestRun <- length(bestRun) # HD: it goes faster if you cal a function only once where possible.
  specificity_scores <- vector("numeric", nBestRun)
  sensitivity_scores <- vector("numeric", nBestRun)
  f1_scores <- vector("numeric", nBestRun)
  MCC_scores <- vector("numeric", nBestRun)
  
  # Loop over each element in bestRun and calculate the performance metrics
  for (i in 1:nBestRun) {
    mat <- Predictions_MCI[[bestRun[i]]]
    specificity_scores[i] <- specificity(TFN_Y, mat)
    sensitivity_scores[i] <- sensitivity(TFN_Y, mat)
    f1_scores[i] <- f1_score(TFN_Y, mat)
    MCC_scores[i] <- MCC(TFN_Y, mat)
  }                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               
  
  # Flatten the lists into vectors
  specificity_scores <- unlist(specificity_scores)
  sensitivity_scores <- unlist(sensitivity_scores)
  f1_scores <- unlist(f1_scores)
  MCC_scores <- unlist(MCC_scores)
  
  Model_accuracy_stats <- data.frame(
    bestRun,
    errorEst,
    # duration_mins,
    Percentage_good,
    specificity_scores,
    sensitivity_scores,
    f1_scores,
    MCC_scores
  )
  
  # Store predicted beta values
  b0_list <- list()
  bi_list <- list()
  names <- c("MSE", "MAE", "RMSE")
  for (i in seq_along(bestRun)) {
    mtx <- bestRun[[i]]
    b0 <- MCI[[2]][mtx,]
    bi <- MCI[[3]][[mtx]]
    b0_list[[names[i]]] <- b0
    bi_list[[names[i]]] <- bi
  }
  
  # Predicted beta values
  b0MSE <- b0_list$MSE[1]
  b0MAE <- b0_list$MAE[1]
  b0RMSE <-b0_list$RMSE[1]
  b1MSE <- bi_list$MSE[1]
  b1MAE <- bi_list$MAE[1]
  b1RMSE <- bi_list$RMSE[1]
  b2MSE <- bi_list$MSE[2]
  b2MAE <- bi_list$MAE[2]
  b2RMSE <- bi_list$RMSE[2]
  b3MSE <- bi_list$MSE[3]
  b3MAE <- bi_list$MAE[3]
  b3RMSE <- bi_list$RMSE[3]
  b4MSE <- bi_list$MSE[4]
  b4MAE <- bi_list$MAE[4]
  b4RMSE <- bi_list$RMSE[4]
  b5MSE <- bi_list$MSE[5]
  b5MAE <- bi_list$MAE[5]
  b5RMSE <- bi_list$RMSE[5]
  b6MSE <- bi_list$MSE[6]
  b6MAE <- bi_list$MAE[6]
  b6RMSE <- bi_list$RMSE[6]
  b7MSE <- bi_list$MSE[7]
  b7MAE <- bi_list$MAE[7]
  b7RMSE <- bi_list$RMSE[7]
  #''''''''''Comment: add more sets of betas here based on number of predictors'''''''''''''''''#
  
  Model_predicted_betas <- c(b0MSE, b0MAE, b0RMSE, b1MSE, b1MAE, b1RMSE, b2MSE, b2MAE, b2RMSE, 
                             b3MSE, b3MAE, b3RMSE, b4MSE, b4MAE, b4RMSE, b5MSE, b5MAE, b5RMSE,
                             b6MSE, b6MAE, b6RMSE, b7MSE, b7MAE, b7RMSE)
                             #''''''''''Comment: add more sets of betas here based on number of predictors'''''''''''''''''#
                             
  
  #''''''''''Comment: adjust ncol value on 676 based on number of betas/predictors'''''''''''''''''#
  Model_predicted_betas <- matrix(Model_predicted_betas, nrow = 3, ncol = 8, byrow = TRUE)
  
  rownames(Model_predicted_betas) <- c("MSE", "MAE", "RMSE")
  predicted_betas <- Model_predicted_betas
  
  #---------------------#
  ## --- MODEL END --- ##
  
  write.csv(Model_accuracy_stats, paste0("Model_accuracy_stats_simNum_", simControl,".csv"))
  write.csv(predicted_betas,paste0("predicted_betas_simNum_", simControl,".csv"))
}


