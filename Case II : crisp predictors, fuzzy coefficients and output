
#'''''''''''''Comment: Edit these lines to import a different dataset'''''''''''''''''''''''''''''''
# ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
## Import dataset ##                                                                             #''
#-------------------------------------------------------------------------------#                #''
Immunotherapy <- read.csv("Immunotherapy.csv", header = TRUE)                                    #''
nrow(Immunotherapy) #sample size is 90                                                           #''
ncol(Immunotherapy) #there are 7 variables and 1 response variable called 'Result_of_Treatment'  #''
table(Immunotherapy$Result_of_Treatment) #imbalanced towards 1s (79%)                            #''
str(Immunotherapy)                                                                               #''
#-------------------------------------------------------------------------------#                #''
# ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''




#''''''Comment: Change or add values in lines 25-42 to attempt different scenarios.''''''''''''''''''''''
#'''''''''''''' Once you set these, it will export a CSV which is later imported for implementation.'''''


## Set Model Implementation Settings##
#-------------------------------------------------------------------------------#

b0_lwr <- c(-1)
b0_upper <- c(1)
bi_lower <- c(-1)
bi_upper <- c(1)
Iterations <- c(10000)
Fuzzification_factor <- c(1)
left_point_symmetry <- c(1)
right_point_symmetry <- c(1)
fuz_Y0_min <- c(0)
fuz_Y0_max <- c(1.5)
fuz_Y1_min <- c(0)
fuz_Y1_max <- c(1.5)
TFNthreshold_1 <- c(0.4)
TFNthreshold_2 <- c(0.5)
TFNthreshold_3 <- c(0.6)
ARRAYthreshold_1 <- c(0.4)
ARRAYthreshold_2 <- c(0.5)
ARRAYthreshold_3 <- c(0.6)
N <- nrow(Immunotherapy)

# (i) Join Actual bs with Model bs info
dfi_i_comb <- data.frame(b0_lwr, b0_upper, bi_lower, bi_upper)

# (ii) = join iterations with fuzzification and asymmetry info
df_iter <- data.frame(Iterations)
df_fuzzy <- data.frame(Fuzzification_factor)
df_assymetry <- data.frame(left_point_symmetry,right_point_symmetry)
df_iter_repeated <- data.frame(df_iter[rep(seq_len(nrow(df_iter)), each=nrow(df_fuzzy)),])
df_iter_fuzzy <- cbind(df_iter_repeated, df_fuzzy)
df_iter_fuzzy_repeated <- data.frame(df_iter_fuzzy[rep(seq_len(nrow(df_iter_fuzzy)), each=nrow(df_assymetry)),])
df_iter_fuzzy_assymetry <- cbind(df_iter_fuzzy_repeated, df_assymetry)

# (iii) = join threshold with N and fuzzification of Y limits info
df_thres <- data.frame(TFNthreshold_1, TFNthreshold_2, TFNthreshold_3, ARRAYthreshold_1, ARRAYthreshold_2, ARRAYthreshold_3)
df_N <- data.frame(N)
df_N_repeated <- data.frame(df_N[rep(seq_len(nrow(df_N)), each=nrow(df_thres)),])
df_N_thres <- cbind(df_N_repeated, df_thres)
df_fuz_lmt <- data.frame(fuz_Y0_min, fuz_Y0_max, fuz_Y1_min, fuz_Y1_max)
df_N_thres_repeated <- data.frame(df_N_thres[rep(seq_len(nrow(df_N_thres)), each=nrow(df_fuz_lmt)),])
df_N_thres_fuzlmt <- cbind(df_N_thres_repeated, df_fuz_lmt)

# (iv) final joins
df_iii_repeated <- data.frame(df_N_thres_fuzlmt[rep(seq_len(nrow(df_N_thres_fuzlmt)), each=nrow(dfi_i_comb)),])
df_i_iii_join <- cbind(df_iii_repeated, dfi_i_comb)
df_ii_repeated <- data.frame(df_iter_fuzzy_assymetry[rep(seq_len(nrow(df_iter_fuzzy_assymetry)), each=nrow(df_i_iii_join)),])
df_final <- cbind(df_ii_repeated,df_i_iii_join)

# Final Data prep and export
nrow(df_final) #gives final number of scenarios

colnames(df_final)[1] <- "Iterations"
colnames(df_final)[2] <- "Fuzzification_Factor"
colnames(df_final)[3] <- "Left_Point_Symmetry"
colnames(df_final)[4] <- "Right_Point_Symmetry"
colnames(df_final)[5] <- "N_size_for_Xi"
colnames(df_final)[6] <- "TFN_Threshold_a"
colnames(df_final)[7] <- "TFN_Threshold_b"
colnames(df_final)[8] <- "TFN_Threshold_c"
colnames(df_final)[9] <- "ARRAYthreshold_a"
colnames(df_final)[10] <- "ARRAYthreshold_b"
colnames(df_final)[11] <- "ARRAYthreshold_c"
colnames(df_final)[12] <- "Fuzzy_Y0_min_limit"
colnames(df_final)[13] <- "Fuzzy_Y0_max_limit"
colnames(df_final)[14] <- "Fuzzy_Y1_min_limit"
colnames(df_final)[15] <- "Fuzzy_Y1_max_limit"

write.csv(df_final, "Model_Parameter_Settings.csv")




## Fuzzy Logistic Regression Model ##
#-------------------------------------------------------------------------------#

library(FuzzyR)
library(openxlsx)
library(FuzzyNumbers)
library(Rfast)

#############################################
#### Required Functions & Error Measures ####
#############################################

#--------------------------------------------------------------------------------------------------#
# Addition Function
add_TFN <- function(TFN1, TFN2) {
  TFN3 <- c((TFN1[1]+TFN2[1]) , (TFN1[2]+TFN2[2]) , (TFN1[3]+TFN2[3]))
  TFN3
}


# Subtraction Function
sub_TFN <- function(TFN1, TFN2) {
  TFN3 <- c((TFN1[1]-TFN2[3]) , (TFN1[2]-TFN2[2]) , (TFN1[3]-TFN2[1]))
  TFN3
}


# Multiplication Function
mult_TFN <- function(TFN1, TFN2) {
  TFN3 <- array(NA,3)
  TFN3[1] <- min(TFN1[1]*TFN2[1] , TFN1[1]*TFN2[3] , TFN1[3]*TFN2[1] , TFN1[3]*TFN2[3])
  TFN3[2] <- TFN1[2]*TFN2[2]
  TFN3[3] <- max(TFN1[1]*TFN2[1] , TFN1[1]*TFN2[3] , TFN1[3]*TFN2[1] , TFN1[3]*TFN2[3])
  TFN3
}


# Division Function
div_TFN <- function(TFN1, TFN2) {
  TFN3 <- array(NA,3)
  TFN3[1] <- min(TFN1[1]/TFN2[1] , TFN1[1]/TFN2[3] , TFN1[3]/TFN2[1] , TFN1[3]/TFN2[3])
  TFN3[2] <- TFN1[2]/TFN2[2]
  TFN3[3] <- max(TFN1[1]/TFN2[1] , TFN1[1]/TFN2[3] , TFN1[3]/TFN2[1] , TFN1[3]/TFN2[3])
  TFN3
}


# Membership Function using FuzzyR
fn_member_grades <- function(TFN, MTX, x){
  w <- MTX[TFN,]
  mf <- genmf('trimf', w)
  print("The a-cut evaluation of x elemnents is:")
  e <- evalmf(x, mf)
  e <- cbind(e, x)
  return(list(TFN_Selected = w, MF_Evaluation = e))
}


# Alpha-cut interval using FuzzyR
a_cut_mf <- function(TFN, alpha, x) {
  w <- TFN
  mf <- genmf('trimf', w)
  e <- evalmf(x, mf)
  edf <- data.frame(e, x)
  edf <- subset(edf, e>=a)
  edf
}


# Definition 2.4 - method a
abs_tfn_1 <- function(TFN){
  abs_w <- array(NA,3)
  w <- TFN
  abs_w[1] <- max(min(w) , -max(w) , 0)
  abs_w[2] <- if (w[2]>=0) {
    w[2]
  } else if (w[2]<0) {
    abs(w[2])
  } 
  abs_w[3] <- max(-min(w) , max(w)) 
  abs_w
}


# Definition 2.4 - method b
abs_tfn_2 <- function(TFN){
  abs_w <- array(NA,3)
  w <- TFN
  abs_w[1] <- max(min(w) , -max(w) , 0) 
  abs_w[3] <- max(-min(w) , max(w))
  distw <- (w[2]-w[1])/(w[3]-w[1])
  distabsw <- abs_w[3]-abs_w[1]
  abs_w[2] <- abs_w[1]+(distw*distabsw)
  abs_w
}


# Definition 2.5
random_crisps <- function(n, min, max) {
  round(runif(n = n, min=min, max=max), 3)
}


# Definition 2.6
random_TFNs <- function(min, max, n=3) {
  round(sort(runif(n = n, min=min, max=max)),3)
}

Random_TFNs_norm <- function(mean, sd, n=3) {
  round(sort(rnorm(n = n, mean=mean, sd=sd)),3)
}


# Calculate MSE
MSE_calc <- function(actual,predicted) {
  if (nrow(actual) != nrow(predicted)){
    stop("Unequal number of numbers in actual and predicted!")
  }
  n <- nrow(actual)
  total <- 0
  for(i in 1:n){
    total <- total + sum((actual[i,]-predicted[i,])^2)
  }
  MSE_fuzzy = total / n
  return(MSE_fuzzy = MSE_fuzzy)
}


# Root Mean Squared Error
RMSE <- function(actual, predicted) {
  n_rows <- nrow(predicted)
  rmse <- numeric(n_rows)
  for (i in 1:n_rows) {
    rmse[i] <- sqrt(mean((predicted[i,] - actual[i,])^2))
  }
  avg_rmse <- mean(rmse)
  return(avg_rmse)
}


# MAE
MAE_calc <- function(actual,predicted) {
  if (nrow(actual) != nrow(predicted)){
    stop("Unequal number of numbers in actual and predicted!")
  }
  n <- nrow(actual)
  total <- 0
  for(i in 1:n){
    total <- total + sum(abs(actual[i,]-predicted[i,]))
    MAE_fuzzy <- total / n
  }
  return(MAE_fuzzy = MAE_fuzzy)
}


# Specificity
specificity <- function(actuals, predictions) {
  # Define the threshold for classification
  threshold <- 0.5
  # Convert the matrices to vectors
  actuals_vec <- as.vector(actuals)
  predictions_vec <- as.vector(predictions)
  # Determine the true negatives and false positives
  tn <- sum(actuals_vec < threshold & predictions_vec < threshold)
  fp <- sum(actuals_vec < threshold & predictions_vec >= threshold)
  # Calculate specificity
  specificity <- tn / (tn + fp)
  return(specificity)
}


# Sensitivity
sensitivity <- function(actuals, predictions) {
  # Define the threshold for classification
  threshold <- 0.5
  # Convert the matrices to vectors
  actuals_vec <- as.vector(actuals)
  predictions_vec <- as.vector(predictions)
  # Determine the true positives and false negatives
  tp <- sum(actuals_vec >= threshold & predictions_vec >= threshold)
  fn <- sum(actuals_vec >= threshold & predictions_vec < threshold)
  # Calculate sensitivity
  sensitivity <- tp / (tp + fn)
  return(sensitivity)
}


# F1 Score
f1_score <- function(actuals, predictions) {
  # Define the threshold for classification
  threshold <- 0.5
  # Convert the matrices to vectors
  actuals_vec <- as.vector(actuals)
  predictions_vec <- as.vector(predictions)
  # Determine the true positives, false positives, and false negatives
  tp <- sum(actuals_vec >= threshold & predictions_vec >= threshold)
  fp <- sum(actuals_vec < threshold & predictions_vec >= threshold)
  fn <- sum(actuals_vec >= threshold & predictions_vec < threshold)
  # Calculate precision and recall
  precision <- tp / (tp + fp)
  recall <- tp / (tp + fn)
  # Calculate F1 score
  f1_score <- 2 * precision * recall / (precision + recall)
  return(f1_score)
}

# MCC (Matthews Correlation Coefficient)
MCC <- function(actual, predicted) {
  # Calculate the MCC for each row of the matrices
  m <- nrow(actual)
  mcc_vals <- numeric(m)
  for (i in 1:m) {
    a <- actual[i, ]
    p <- predicted[i, ]
    # Calculate the confusion matrix
    tp <- sum(p >= a & p <= a[3])
    tn <- sum(p <= a & p >= a[1])
    fp <- sum(p > a[3])
    fn <- sum(p < a[1])
    # Calculate MCC
    num <- tp * tn - fp * fn
    denom <- sqrt((tp + fp) * (tp + fn) * (tn + fp) * (tn + fn))
    if (denom == 0) {
      mcc_vals[i] <- 0
    } else {
      mcc_vals[i] <- num / denom
    }
  }
  # Return the average MCC across all rows
  mean(mcc_vals)
}



# Function to find p values from predictors
find_p <- function(b0, b, ...) {
  X <- do.call(cbind, c(list(1), list(...)))
  b <- c(b0, b)
  return(exp(X %*% b) / (1 + exp(X %*% b)))
}


# Function to estimate Y
Estimate_Y_cs2_logit <- function(X, b.lwr, b.upr, b0.lwr, b0.upr){
  Np <- ncol(X) 
  b0 <- random_TFNs(b0.lwr, b0.upr) 
  b <- matrix(NA, nrow = Np, ncol = 3)
  for (i in 1:Np) {
    b[i,] <- random_TFNs(b.lwr[i], b.upr[i]) 
  }
  n <- nrow(X) 
  predy <- matrix(NA, nrow = n, ncol = 3)
  for (i in 1:n) {  
    bx <- b0 
    for(j in 1:Np) {
      bx <- add_TFN( bx , mult_TFN(b[j,],c(X[i,j], X[i,j] , X[i,j] )) )
    }
    predy[i,] <- div_TFN(c(1,1,1), (1 + exp(mult_TFN(c(-1,-1,-1),bx)))) # 1 /(1+exp(-X*b))
  }
  return(list("predictions" = predy, "b0" = b0, "bi" = b))
}


# Function to run estimate_Y many times
Optimize_Y_gen <- function(m, X, b.lwr, b.upr, b0.lwr, b0.upr){
  results <- list()
  for (i in 1:m) {
    results[[i]] <- Estimate_Y_cs2_logit(X, b.lwr, b.upr, b0.lwr, b0.upr)
  }
  # store all predictions
  store_predY <- list()
  for (i in 1:m) {
    store_predY[[i]] <- results[[i]]$predictions
  }
  # store all beta 0
  store_b0 <- matrix(NA, nrow = m, ncol = 3)
  for (i in 1:m) {
    store_b0[i,] <- results[[i]]$b0
  }
  # store all beta i
  store_bi <- list()
  for (i in 1:m) {
    store_bi[[i]] <- results[[i]]$bi
  }
  output_list <- list(store_predY, store_b0, store_bi)
}


# Function to find error
Error_cs_gen <- function(Experiment, Y, saveResults = TRUE){
  store_predY <- Experiment
  t <- length(store_predY)
  MSE_list <- list() 
  MAE_list <- list()
  RMSE_list <- list()
  for (i in 1:t) {
    MSE_list[[i]] <- MSE_calc(Y,store_predY[[i]])
    MAE_list[[i]] <- MAE_calc(Y,store_predY[[i]])
    RMSE_list[[i]] <- RMSE(Y,store_predY[[i]])
  }
  mtx_seq <- seq(1:Iterations) 
  error_results <- do.call(rbind, Map(data.frame, Matrix=mtx_seq, MSE=MSE_list, MAE=MAE_list ,RMSE=RMSE_list))
  if (saveResults){
    write.csv(error_results, "error_results.csv")
  }
  return(error_results)
}

# Function to fuzzify Y values
fuzzify_Y <- function(Y, m, l=1, r=1){ 
  center_point <- ifelse(Y == 0, 0, 1) 
  set.seed(123) 
  left_point <- array(NA, length(center_point))
  right_point <- array(NA, length(center_point))
  left_point[which(center_point == 0)] <- 0 - l * m * runif(length(which(center_point == 0)), min = fuzzy_y0_min, max = fuzzy_y0_max) 
  right_point[which(center_point == 0)]  <- 0 + r * m * runif(length(which(center_point == 0)), min = fuzzy_y0_min, max = fuzzy_y0_max)
  
  left_point[which(center_point == 1)] <- 1 - l * m * runif(length(which(center_point == 1)), min = fuzzy_y1_min, max = fuzzy_y1_max) 
  right_point[which(center_point == 1)]  <- 1 + r * m * runif(length(which(center_point == 1)), min = fuzzy_y1_min, max = fuzzy_y1_max)
  
  
  TFN_Y_df <- data.frame(left_point, center_point, right_point) 
  TFN_Y <- as.matrix(TFN_Y_df) 
  return(TFN_Y)
}
#-------------------------------------------------------------------------------------------------------------------#





## --- MODEL START --- ##
#-----------------------#
# startTime = proc.time()

###############################
#### Simulation Parameters ####
###############################

# Import simulation settings file
model_settings <- read.csv("Model_Parameter_Settings.csv")
str(model_settings) #str to check

for ( simControl in 1:nrow(model_settings)){
  
  # Input parameters
  iterations <- model_settings$Iterations[simControl]
  fuzzy_factor <- model_settings$Fuzzification_Factor[simControl]
  left_symmetry <- model_settings$Left_Point_Symmetry[simControl]
  right_symmetry <- model_settings$Right_Point_Symmetry[simControl]
  N_of_X <- model_settings$N_size_for_Xi[simControl]
  TFN_threshold_a <- model_settings$TFN_Threshold_a[simControl]
  TFN_threshold_b <- model_settings$TFN_Threshold_b[simControl]
  TFN_threshold_c <- model_settings$TFN_Threshold_c[simControl]
  fuzzy_y0_min <- model_settings$Fuzzy_Y0_min_limit[simControl]
  fuzzy_y0_max <- model_settings$Fuzzy_Y0_max_limit[simControl]
  fuzzy_y1_min <- model_settings$Fuzzy_Y1_min_limit[simControl]
  fuzzy_y1_max <- model_settings$Fuzzy_Y1_max_limit[simControl]
  pred_b0_lwr <- model_settings$b0_lwr[simControl]
  pred_b0_upr <- model_settings$b0_upper[simControl]
  pred_b1_lwr <- model_settings$bi_lower[simControl]
  pred_b1_upr <- model_settings$bi_upper[simControl]
  pred_b2_lwr <- model_settings$bi_lower[simControl]
  pred_b2_upr <- model_settings$bi_upper[simControl]
  pred_b3_lwr <- model_settings$bi_lower[simControl]
  pred_b3_upr <- model_settings$bi_upper[simControl]
  pred_b4_lwr <- model_settings$bi_lower[simControl]
  pred_b4_upr <- model_settings$bi_upper[simControl]
  pred_b5_lwr <- model_settings$bi_lower[simControl]
  pred_b5_upr <- model_settings$bi_upper[simControl]
  pred_b6_lwr <- model_settings$bi_lower[simControl]
  pred_b6_upr <- model_settings$bi_upper[simControl]
  pred_b7_lwr <- model_settings$bi_lower[simControl]
  pred_b7_upr <- model_settings$bi_upper[simControl]
      #''''''Comment: Add more pred_bi_lwr and pred_bu_upr values here, depending on the number of predictors''''''''

  
  
  
  ## Model settings ##
  #------------------#
  bi_lower <- c(pred_b1_lwr, pred_b2_lwr, pred_b3_lwr, pred_b4_lwr, pred_b5_lwr, pred_b6_lwr, pred_b7_upr)
  bi_upper <- c(pred_b1_upr, pred_b2_upr, pred_b3_upr, pred_b4_upr, pred_b5_upr, pred_b6_upr, pred_b7_upr)
        #''''''Comment: adjust lines 476-477 depending on number of predictors''''''''
  
  b0_lwr <- pred_b0_lwr
  b0_upper <- pred_b0_upr
  
  Xmtx <- cbind(Immunotherapy$age, Immunotherapy$Time, Immunotherapy$Number_of_Warts, Immunotherapy$Type,
                Immunotherapy$Area, Immunotherapy$induration_diameter, Immunotherapy$sex)
      #''''''Comment: adjust lines 483-484 depending on number of predictors''''''''       
  
  Iterations <- iterations
  Fuzzification_factor <- fuzzy_factor
  left_point_symmetry <- left_symmetry
  right_point_symmetry <- right_symmetry
  Y <- Immunotherapy$Result_of_Treatment
  #------------------#

  
  ## Model Run below ##

  # Fuzzify the Ys
  TFN_Y <- fuzzify_Y(Y, Fuzzification_factor, l=left_point_symmetry, r=right_point_symmetry)
  
  # MC-I 
  MCI <- Optimize_Y_gen(Iterations, Xmtx, bi_lower, bi_upper, b0_lwr, b0_upper)
  Predictions_MCI <- MCI[[1]] 
  
  # Compare each vertex position for each predicted p against 0.5 and replace with 0s or 1s.
  TFNthreshold <- TriangularFuzzyNumber(TFN_threshold_a, TFN_threshold_b, TFN_threshold_c) 
  ARRAYthreshold <- c(TFN_threshold_a, TFN_threshold_b, TFN_threshold_c)
  
  for (i in 1:length(Predictions_MCI)) {
    mat <- Predictions_MCI[[i]]
    for (j in 1:nrow(mat)){
      TFNprob <- TriangularFuzzyNumber(mat[j,1], mat[j,2], mat[j,3])
      diffTFN <- sub_TFN(mat[j,], ARRAYthreshold )
      diffTFN <-  TriangularFuzzyNumber(diffTFN[1],diffTFN[2],diffTFN[3])
      
      # Use the expected value of TFN predicted probability to decide on the vertex being 0 or 1
      if (expectedValue(TFNprob) < 0.5){ # Dubois D., Prade H. (1987), The mean value of a fuzzy number, Fuzzy Sets and Systems 24, pp. 279-300.
        b_thresholded <- 0
      } else {
        b_thresholded <- 1
      }
      # Use the width of the difference between the TFN threshold and TFN predicted probability to add uncertainty around 0 or 1.
      a_new <- b_thresholded - width(diffTFN)
      c_new <- b_thresholded + width(diffTFN)
      
      # shiftedTFN <- TriangularFuzzyNumber(a_new, b_thresholded, c_new)
      
      mat[j, 2] <- b_thresholded
      mat[j, 1] <- a_new
      mat[j, 3] <- c_new
    }
    Predictions_MCI[[i]] <- mat
  }
  
  # Filter good predictions
  #Predictions_MCI_good <- filter_matrices(Predictions_MCI)
  
  # Error Optimization
  errors <- Error_cs_gen(Predictions_MCI, TFN_Y)
  
  bestRun <- as.array(colMins(as.matrix(errors[,-c(1)])))
  names(bestRun) <- colnames(errors[,-c(1)])
  errorEst <- round(apply(errors, 2, min), 3)
  errorEst <- errorEst[2:4]
  # 
  # stopTime = proc.time()
  # duration = as.numeric(stopTime - startTime)
  #   duration = round((duration/60),2)
  #   duration_mins <- c(duration[3],duration[3],duration[3])
  
  # Check for number of good predictions 
  numLess <- array()
  for (ii in 1:Iterations){
    numLess[ii] <- length(which(Predictions_MCI[[ii]][,2]<0.5))
  }
  Percentage_good <- sum(numLess > 20 & numLess < 80)/Iterations
  Percentage_good <- c(Percentage_good,Percentage_good,Percentage_good)
  
  # Initialize empty vectors to store the performance metrics for each run
  nBestRun <- length(bestRun) # HD: it goes faster if you cal a function only once where possible.
  specificity_scores <- vector("numeric", nBestRun)
  sensitivity_scores <- vector("numeric", nBestRun)
  f1_scores <- vector("numeric", nBestRun)
  MCC_scores <- vector("numeric", nBestRun)
  
  # Loop over each element in bestRun and calculate the performance metrics
  for (i in 1:nBestRun) {
    mat <- Predictions_MCI[[bestRun[i]]]
    specificity_scores[i] <- specificity(TFN_Y, mat)
    sensitivity_scores[i] <- sensitivity(TFN_Y, mat)
    f1_scores[i] <- f1_score(TFN_Y, mat)
    MCC_scores[i] <- MCC(TFN_Y, mat)
  }                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               
  
  # Flatten the lists into vectors
  specificity_scores <- unlist(specificity_scores)
  sensitivity_scores <- unlist(sensitivity_scores)
  f1_scores <- unlist(f1_scores)
  MCC_scores <- unlist(MCC_scores)
  
  Model_accuracy_stats <- data.frame(
    bestRun,
    errorEst,
    Percentage_good,
    specificity_scores,
    sensitivity_scores,
    f1_scores,
    MCC_scores
  )
  
  # Store predicted beta values
  b0_list <- list()
  bi_list <- list()
  names <- c("MSE", "MAE", "RMSE")
  for (i in seq_along(bestRun)) {
    mtx <- bestRun[[i]]
    b0 <- MCI[[2]][mtx,]
    bi <- MCI[[3]][[mtx]]
    b0_list[[names[i]]] <- b0
    bi_list[[names[i]]] <- bi
  }
  Model_predicted_beta0s <- do.call(rbind, b0_list)
  rownames(Model_predicted_beta0s) <- c("b0:MSE", "b0:MAE", "b0:RMSE")
  Model_predicted_betais <- do.call(rbind, bi_list)
  rownames(Model_predicted_betais) <- c("b1:MSE", "b1:MAE", "b1:RMSE", "b2:MSE", "b2:MAE", "b2:RMSE", 
                                        "b3:MSE", "b3:MAE", "b3:RMSE", "b4:MSE", "b4:MAE", "b4:RMSE",
                                        "b5:MSE", "b5:MAE", "b5:RMSE", "b6:MSE", "b6:MAE", "b6:RMSE",
                                        "b7:MSE", "b7:MAE", "b7:RMSE")   #''''''Comment: add more betas here if you have more predictors''''''''
                                        
  predicted_betas <- rbind(Model_predicted_beta0s,Model_predicted_betais)
  colnames(predicted_betas) <- c("TFN a", "TFN b", "TFN c")
  
  #---------------------#
  ## --- MODEL END --- ##
  
  write.csv(Model_accuracy_stats, paste0("Model_accuracy_stats_simNum_", simControl,".csv"))
  write.csv(predicted_betas,paste0("predicted_betas_simNum_", simControl,".csv"))
}

